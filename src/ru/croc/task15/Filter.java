package ru.croc.task15;

import java.util.Arrays;
import java.util.function.Predicate;

/**
 *
 * Вы реализовали фильтрацию комментариев по “черному списку” слов (задача
 * 13) и с чистой совестью ушли в отпуск на 3 недели.
 *
 * По возвращении из отпуска вы обнаружили, что логика фильтрации услож-
 * нилась. Также выяснилось, что нет единого способа представления коммента-
 * риев среди сервисов: где-то они представлены строками, где-то объектами
 * специализированных классов. Вдобавок некоторым сервисам оказалось неудоб-
 * ным передавать набор комментариев на фильтрацию в виде списка и предпо-
 * чтительнее коллекция другого типа.
 *
 * В результате разработчики разных сервисов реализовали копии методов для
 * применения правил “черного списка”, учитывающие специфику их сервисов. А
 * так как правила фильтрации тоже менялись в процессе, эти методы правились
 * не совместно, что привело к плохо читаемому и поддерживаемому коду: логика
 * с одной стороны дублируется, но с другой - работает в каждом методе по-
 * особенному.
 *
 * Вы берете дело в свои руки и решаете реализовать единый метод фильтра-
 * ции, учитывающий все обнаруженные особенности. В ходе анализа кода вы
 * отмечаете для себя следующее:
 * 1. Условия фильтрации в разных сервисах различаются и нет возможности
 * обобщить их в рамках одного метода. Поэтому способ фильтрации вы решаете
 * представлять в виде предиката (см. https://docs.oracle.com/javase/8/
 * docs/api/java/util/function/Predicate.html) и позволять определять его
 * вызывающим сервисам.
 * 2. Набор используемых сервисами классов-представлений для комментариев
 * обширен (String, Comment, CommentDto, ...) и, возможно, будет и в дальнейшем
 * расширяться.
 * 3. Сервисы работают с наборами комментариев в виде коллекций разных
 *
 * типов (HashSet, ArrayList, ArrayDeque, ...), но все они имплементируют ин-
 * терфейс Iterable.
 *
 * 4. Результат фильтрации удобнее представлять в виде отдельной коллек-
 * ции-возвращаемого значения метода, а исходную коллекцию при этом не моди-
 * фицировать. Некоторым сервисам важен порядок следования комментариев, по-
 * этому он должен быть сохранен в отфильтрованном результате.
 *
 * Обновите интерфейс BlackListFilter и реализуйте новый механизм филь-
 * трации в виде default-метода.
 *
 */

public class Filter implements BlackListFilter {
    public static void main(String[] args) {

        Iterable<String> comments = Arrays.asList("hate c++", "love java", "whatever javaScript");

        Predicate<String> containsHate = t -> t.contains("hate");
        Predicate<String> containsWhatever = t -> t.contains("whatever");

    }

}

